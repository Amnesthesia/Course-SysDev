\subsection{Front-end}
Web sites are conventionally made using the standard languages provided for it: HTML, CSS, and JavaScript. However, it's becoming increasingly popular to instead work with abstractions of these in the form of frameworks or languages that is parsed or compile into native javascript or CSS for various reasons. With native applications, running as standalone programs on a computer, we have frameworks such as .NET to speed up development by letting developers spend more time on solving \textit{relevant} problems for the application, instead of solving \textit{trivial} problems (such as string or data processing).

Today, a lot of applications are moving more and more to the web, but the basic concept is very similar: Code is downloaded and run locally, and displays information retrieved over the web. The main difference is that with web application, code runs in a sandbox (the web browser). Therefore, we have taken a look at various front-end frameworks for developing web applications almost on par with native applications, without wasting time on reinventing the wheel.   

\subsubsection{Design pattern}

MVC has become more or less a standard way of decomposing web applications into different components (models, views and controllers), which makes it easy to modify or add new components of either type independently. Because the application has a lot of data that is simply presented in different ways (listing of episodes, shows, and so on), it seems logical to use a framework that makes use of this design pattern.

\subsubsection{Technology}
After comparing two of the most prominent javascript frameworks, Angular and Ember, it was found that Angular's \textit{dirty checking} leads to less than optimal performance when the DOM containes a large amount of elements, an issue not present in Ember. Since the application will be working with large sets of data in the form of TV shows, displaying an ever increasing list of shows, and thus may have a huge amount of elements in the DOM, this is a requirement Ember can satisfy.

Ember takes inspiration from already mature open source technology before it -- such as Backbone.js and Ruby on Rails -- and uses the familiar terminology of Models, Views and Controllers, whereas Angular introduces concepts such as directives, scopes and transclusion, which makes Ember faster to get started with than Angular.

Furthermore, for the web application to be easily extensible with e.g mobile apps or 3rd party apps, it would make sense for the back-end to provide an API in the form of web services. Not only is this useful for mobile apps or 3rd party apps, but it's how Ember works with data by default: It works with data retrieved from RESTful web services, and this in turn helps separating the front-end from the back-end while also allowing the front-end to run on a completely different server, should this be needed in the future. 

Separating the front-end and the back-end allows for different software architectures for the front-end and the back-end, and allows them to be developed independently. It lets the front-end operate as a client retrieving and modifying sets of data from the server via the API, just as any other form of client would.

Ember uses RequireJS, which makes development modular by allowing code to be written as packages and included as needed -- a feature that goes hand in hand with the SCRUM development methodology. Each package provides a list of dependencies, as does the application itself, so including the correct version and in the right order can be done automatically, and different releases can depend on different version of packages. Additionally, \textit{views} can be displayed with different \textit{templates} as Ember fully supports and promotes Handlebars for templating, which makes displaying the same data in different forms rather easy.

One of the key advantages of Ember is data binding. Data binding means that when a property present in multiple object changes in one object, it's also updated in other objects. Another advantage is state-management (is a user logged in or out?), and auto-updating of templates when the underlying data changes. For example, when a user decides to \textit{subscribe} to a TV show, any other elements listing shows the user has subscribed to would be updated with the new subscription. 